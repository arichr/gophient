{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Gophient Gophient is client library for the Gopherspace. It doesn't require any dependencies and is easy to use. Features: Browse the Gopherspace Follow links Download content Examples Get weather from Floodgap import gophient client = gophient . Gopher () weather = client . request ( 'gopher.floodgap.com' , 'groundhog/ws' ) print ( weather ) Search by Veronica import gophient client = gophient . Gopher () results = client . request ( 'gopher.floodgap.com' , 'v2/vs' , query = 'plan 9' ) print ( results ) Download files import gophient client = gophient . Gopher () apk = client . request ( 'gopher.floodgap.com' , 'overbite/files/OverbiteAndroid025.apk' ) with open ( 'app.apk' , 'wb' ) as apk_file : apk_file . write ( apk )","title":"Home"},{"location":"#gophient","text":"Gophient is client library for the Gopherspace. It doesn't require any dependencies and is easy to use. Features: Browse the Gopherspace Follow links Download content","title":"Gophient"},{"location":"#examples","text":"","title":"Examples"},{"location":"#get-weather-from-floodgap","text":"import gophient client = gophient . Gopher () weather = client . request ( 'gopher.floodgap.com' , 'groundhog/ws' ) print ( weather )","title":"Get weather from Floodgap"},{"location":"#search-by-veronica","text":"import gophient client = gophient . Gopher () results = client . request ( 'gopher.floodgap.com' , 'v2/vs' , query = 'plan 9' ) print ( results )","title":"Search by Veronica"},{"location":"#download-files","text":"import gophient client = gophient . Gopher () apk = client . request ( 'gopher.floodgap.com' , 'overbite/files/OverbiteAndroid025.apk' ) with open ( 'app.apk' , 'wb' ) as apk_file : apk_file . write ( apk )","title":"Download files"},{"location":"docs/quick_start/1_-_Installation/","text":"To install gophient into your current environment: $ pip install gophient Or with Poetry: $ poetry add gophient","title":"1. Installation"},{"location":"docs/quick_start/2_-_API/","text":"To start using gophient import it and create a Gopher class instance: import gophient client = gophient . Gopher () For a full definition of the API see the API reference documentation .","title":"2. API"},{"location":"reference/gophient/","text":"Module gophient gophient - Client library for the Gopherspace. None View Source \"\"\"gophient - Client library for the Gopherspace.\"\"\" from gophient import const , exc , types from gophient.types import Gopher __all__ = ( 'const' , 'exc' , 'types' , 'Gopher' , ) Sub-modules gophient.const gophient.exc gophient.types Variables const exc types Classes Gopher class Gopher ( timeout : int = 10 , encoding : str = 'utf-8' ) View Source class Gopher : \"\"\"Class for Gopher client.\"\"\" def __init__ ( self , timeout : int = 10 , encoding : str = 'utf-8' ): \"\"\"Initialize a client. Args: timeout (int): Socket timeout encoding (str): Encoding for packets. Defaults to `'utf-8'` \"\"\" self . timeout = timeout self . encoding = encoding def _open_socket ( self ) -> socket . socket : \"\"\"Open a `socket.socket`. Returns: socket.socket \"\"\" return socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) def _prepare_payload ( self , path : str , query : Union [ str , ByteString , None ] = None ) -> bytes : \"\"\"Prepare a payload. Args: path (str): Path query (Union[str, ByteString, None]): Query. Defaults to `None`. Returns: bytes \"\"\" if isinstance ( query , str ): query = bytes ( urllib . parse . quote ( query , safe = '' ), self . encoding ) elif query is None : query = b '' path = bytes ( path , self . encoding ) return b '' . join (( path , b '?' , query , const . EOL )) def parse_response ( self , resp : ByteString ) -> Union [ List [ Item ], list , ByteString ]: \"\"\"Parse the server response. Args: resp (ByteString): Response Returns: Union[List[Item], list, ByteString] \"\"\" pretty_resp = [] for item in resp . split ( const . EOL ): item = Item . parse ( self , item ) if not item : continue if item . raw_type == '\uab30' : return resp if item . raw_type == 'i' and pretty_resp : if pretty_resp [ - 1 ] . raw_type == 'i' : pretty_resp [ - 1 ] . merge_messages ( item ) continue pretty_resp . append ( item ) return pretty_resp def request ( self , host : str , path : str = '/' , port : int = 70 , query : Union [ str , ByteString , None ] = None , ) -> Union [ List [ Item ], list , ByteString ]: \"\"\"Request an address. Args: host (str): Host to connect to path (str): Path. Defaults to `'/'` port (int): Port query (Union[str, ByteString, None]): Query Returns: Union[List[Item], list, ByteString] \"\"\" sock = self . _open_socket () with sock : socket . timeout ( self . timeout ) sock . connect (( host , port )) payload = self . _prepare_payload ( path , query ) sock . sendall ( payload ) resp = bytearray () packet = b 'packet' while packet : packet = sock . recv ( 1024 ) resp . extend ( packet ) return self . parse_response ( resp ) Methods parse_response def parse_response ( self , resp : ByteString ) -> Union [ List [ gophient . types . Item ], list , ByteString ] Parse the server response. Parameters: Name Type Description Default resp ByteString Response None Returns: Type Description None Union[List[Item], list, ByteString] View Source def parse_response ( self , resp : ByteString ) -> Union [ List[Item ] , list , ByteString ]: \"\"\"Parse the server response. Args: resp (ByteString): Response Returns: Union[List[Item], list, ByteString] \"\"\" pretty_resp = [] for item in resp . split ( const . EOL ) : item = Item . parse ( self , item ) if not item : continue if item . raw_type == '\uab30' : return resp if item . raw_type == 'i' and pretty_resp : if pretty_resp [ -1 ] . raw_type == 'i' : pretty_resp [ -1 ] . merge_messages ( item ) continue pretty_resp . append ( item ) return pretty_resp request def request ( self , host : str , path : str = '/' , port : int = 70 , query : Union [ str , ByteString , NoneType ] = None ) -> Union [ List [ gophient . types . Item ], list , ByteString ] Request an address. Parameters: Name Type Description Default host str Host to connect to None path str Path. Defaults to '/' None port int Port None query Union[str, ByteString, None] Query None Returns: Type Description None Union[List[Item], list, ByteString] View Source def request ( self , host : str , path : str = '/' , port : int = 70 , query : Union [ str, ByteString, None ] = None , ) -> Union [ List[Item ] , list , ByteString ]: \"\"\"Request an address. Args: host (str): Host to connect to path (str): Path. Defaults to `'/'` port (int): Port query (Union[str, ByteString, None]): Query Returns: Union[List[Item], list, ByteString] \"\"\" sock = self . _open_socket () with sock : socket . timeout ( self . timeout ) sock . connect (( host , port )) payload = self . _prepare_payload ( path , query ) sock . sendall ( payload ) resp = bytearray () packet = b 'packet' while packet : packet = sock . recv ( 1024 ) resp . extend ( packet ) return self . parse_response ( resp )","title":"Index"},{"location":"reference/gophient/#module-gophient","text":"gophient - Client library for the Gopherspace. None View Source \"\"\"gophient - Client library for the Gopherspace.\"\"\" from gophient import const , exc , types from gophient.types import Gopher __all__ = ( 'const' , 'exc' , 'types' , 'Gopher' , )","title":"Module gophient"},{"location":"reference/gophient/#sub-modules","text":"gophient.const gophient.exc gophient.types","title":"Sub-modules"},{"location":"reference/gophient/#variables","text":"const exc types","title":"Variables"},{"location":"reference/gophient/#classes","text":"","title":"Classes"},{"location":"reference/gophient/#gopher","text":"class Gopher ( timeout : int = 10 , encoding : str = 'utf-8' ) View Source class Gopher : \"\"\"Class for Gopher client.\"\"\" def __init__ ( self , timeout : int = 10 , encoding : str = 'utf-8' ): \"\"\"Initialize a client. Args: timeout (int): Socket timeout encoding (str): Encoding for packets. Defaults to `'utf-8'` \"\"\" self . timeout = timeout self . encoding = encoding def _open_socket ( self ) -> socket . socket : \"\"\"Open a `socket.socket`. Returns: socket.socket \"\"\" return socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) def _prepare_payload ( self , path : str , query : Union [ str , ByteString , None ] = None ) -> bytes : \"\"\"Prepare a payload. Args: path (str): Path query (Union[str, ByteString, None]): Query. Defaults to `None`. Returns: bytes \"\"\" if isinstance ( query , str ): query = bytes ( urllib . parse . quote ( query , safe = '' ), self . encoding ) elif query is None : query = b '' path = bytes ( path , self . encoding ) return b '' . join (( path , b '?' , query , const . EOL )) def parse_response ( self , resp : ByteString ) -> Union [ List [ Item ], list , ByteString ]: \"\"\"Parse the server response. Args: resp (ByteString): Response Returns: Union[List[Item], list, ByteString] \"\"\" pretty_resp = [] for item in resp . split ( const . EOL ): item = Item . parse ( self , item ) if not item : continue if item . raw_type == '\uab30' : return resp if item . raw_type == 'i' and pretty_resp : if pretty_resp [ - 1 ] . raw_type == 'i' : pretty_resp [ - 1 ] . merge_messages ( item ) continue pretty_resp . append ( item ) return pretty_resp def request ( self , host : str , path : str = '/' , port : int = 70 , query : Union [ str , ByteString , None ] = None , ) -> Union [ List [ Item ], list , ByteString ]: \"\"\"Request an address. Args: host (str): Host to connect to path (str): Path. Defaults to `'/'` port (int): Port query (Union[str, ByteString, None]): Query Returns: Union[List[Item], list, ByteString] \"\"\" sock = self . _open_socket () with sock : socket . timeout ( self . timeout ) sock . connect (( host , port )) payload = self . _prepare_payload ( path , query ) sock . sendall ( payload ) resp = bytearray () packet = b 'packet' while packet : packet = sock . recv ( 1024 ) resp . extend ( packet ) return self . parse_response ( resp )","title":"Gopher"},{"location":"reference/gophient/#methods","text":"","title":"Methods"},{"location":"reference/gophient/#parse_response","text":"def parse_response ( self , resp : ByteString ) -> Union [ List [ gophient . types . Item ], list , ByteString ] Parse the server response. Parameters: Name Type Description Default resp ByteString Response None Returns: Type Description None Union[List[Item], list, ByteString] View Source def parse_response ( self , resp : ByteString ) -> Union [ List[Item ] , list , ByteString ]: \"\"\"Parse the server response. Args: resp (ByteString): Response Returns: Union[List[Item], list, ByteString] \"\"\" pretty_resp = [] for item in resp . split ( const . EOL ) : item = Item . parse ( self , item ) if not item : continue if item . raw_type == '\uab30' : return resp if item . raw_type == 'i' and pretty_resp : if pretty_resp [ -1 ] . raw_type == 'i' : pretty_resp [ -1 ] . merge_messages ( item ) continue pretty_resp . append ( item ) return pretty_resp","title":"parse_response"},{"location":"reference/gophient/#request","text":"def request ( self , host : str , path : str = '/' , port : int = 70 , query : Union [ str , ByteString , NoneType ] = None ) -> Union [ List [ gophient . types . Item ], list , ByteString ] Request an address. Parameters: Name Type Description Default host str Host to connect to None path str Path. Defaults to '/' None port int Port None query Union[str, ByteString, None] Query None Returns: Type Description None Union[List[Item], list, ByteString] View Source def request ( self , host : str , path : str = '/' , port : int = 70 , query : Union [ str, ByteString, None ] = None , ) -> Union [ List[Item ] , list , ByteString ]: \"\"\"Request an address. Args: host (str): Host to connect to path (str): Path. Defaults to `'/'` port (int): Port query (Union[str, ByteString, None]): Query Returns: Union[List[Item], list, ByteString] \"\"\" sock = self . _open_socket () with sock : socket . timeout ( self . timeout ) sock . connect (( host , port )) payload = self . _prepare_payload ( path , query ) sock . sendall ( payload ) resp = bytearray () packet = b 'packet' while packet : packet = sock . recv ( 1024 ) resp . extend ( packet ) return self . parse_response ( resp )","title":"request"},{"location":"reference/gophient/const/","text":"Module gophient.const gophient.const - Constants for gophient. None View Source \"\"\"gophient.const - Constants for gophient.\"\"\" EOL = b ' \\r\\n ' SEPARATOR = ' \\t ' TYPES = { # General '0' : 'Text file' , '1' : 'Sub-menu' , '2' : 'CCSO Nameserver' , '3' : 'Failure' , '4' : 'BinHex-encoded file' , '5' : 'DOS file' , '6' : 'uuencoded file' , '7' : 'Full-text search' , '+' : 'Mirror or alternate server' , 'g' : 'GIF file' , 'I' : 'Image file' , 'T' : 'Telnet 3270' , # Gopher+ ':' : 'Bitmap image' , ';' : 'Movie file' , '<' : 'Sound file' , # etc. 'd' : 'Document file' , 'h' : 'HTML file' , 'i' : 'Informational message' , 's' : 'Sound file' , # Especially WAV files # gophient (never use these types to avoid wrong displaying) '\uab30' : 'File' , } Variables EOL SEPARATOR TYPES","title":"Const"},{"location":"reference/gophient/const/#module-gophientconst","text":"gophient.const - Constants for gophient. None View Source \"\"\"gophient.const - Constants for gophient.\"\"\" EOL = b ' \\r\\n ' SEPARATOR = ' \\t ' TYPES = { # General '0' : 'Text file' , '1' : 'Sub-menu' , '2' : 'CCSO Nameserver' , '3' : 'Failure' , '4' : 'BinHex-encoded file' , '5' : 'DOS file' , '6' : 'uuencoded file' , '7' : 'Full-text search' , '+' : 'Mirror or alternate server' , 'g' : 'GIF file' , 'I' : 'Image file' , 'T' : 'Telnet 3270' , # Gopher+ ':' : 'Bitmap image' , ';' : 'Movie file' , '<' : 'Sound file' , # etc. 'd' : 'Document file' , 'h' : 'HTML file' , 'i' : 'Informational message' , 's' : 'Sound file' , # Especially WAV files # gophient (never use these types to avoid wrong displaying) '\uab30' : 'File' , }","title":"Module gophient.const"},{"location":"reference/gophient/const/#variables","text":"EOL SEPARATOR TYPES","title":"Variables"},{"location":"reference/gophient/exc/","text":"Module gophient.exc gophient.exc - Exceptions for gophient. None View Source \" \"\" gophient.exc - Exceptions for gophient. \"\" \" class GopherError ( Exception ) : \" \"\" Main class for all `gophient` exceptions. \"\" \" class TypeMismatchError ( GopherError ) : \" \"\" Items' types mismatch. \"\" \" def __init__ ( self , got : str , expected : str ) : \" \"\" Initialize an exception. Args: got (str): Item type expected (str): Expected type \"\" \" super (). __init__ () self . got = got self . expected = expected self . message = f 'Expected {self.expected!r} (got {self.got!r}).' def __str__ ( self ) -> str : \" \"\" Return a string representation of an exception. Returns: str \"\" \" return self . message def __repr__ ( self ) -> str : \" \"\" Return an object representation. Returns: str \"\" \" return f '<TypeMismatchError message={self.message!r}>' Classes GopherError class GopherError ( / , * args , ** kwargs ) View Source class GopherError ( Exception ) : \" \"\" Main class for all `gophient` exceptions. \"\" \" Ancestors (in MRO) builtins.Exception builtins.BaseException Descendants gophient.exc.TypeMismatchError Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. TypeMismatchError class TypeMismatchError ( got : str , expected : str ) View Source class TypeMismatchError ( GopherError ): \"\"\"Items' types mismatch.\"\"\" def __init__ ( self , got: str , expected: str ): \"\"\"Initialize an exception. Args: got (str): Item type expected (str): Expected type \"\"\" super (). __init__ () self . got = got self . expected = expected self . message = f'Expected { self . expected ! r } ( got { self . got ! r }). ' def __str__(self) -> str: \"\"\"Return a string representation of an exception. Returns: str \"\"\" return self.message def __repr__(self) -> str: \"\"\"Return an object representation. Returns: str \"\"\" return f'<TypeMismatchError message={self.message!r}> ' Ancestors (in MRO) gophient.exc.GopherError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Exc"},{"location":"reference/gophient/exc/#module-gophientexc","text":"gophient.exc - Exceptions for gophient. None View Source \" \"\" gophient.exc - Exceptions for gophient. \"\" \" class GopherError ( Exception ) : \" \"\" Main class for all `gophient` exceptions. \"\" \" class TypeMismatchError ( GopherError ) : \" \"\" Items' types mismatch. \"\" \" def __init__ ( self , got : str , expected : str ) : \" \"\" Initialize an exception. Args: got (str): Item type expected (str): Expected type \"\" \" super (). __init__ () self . got = got self . expected = expected self . message = f 'Expected {self.expected!r} (got {self.got!r}).' def __str__ ( self ) -> str : \" \"\" Return a string representation of an exception. Returns: str \"\" \" return self . message def __repr__ ( self ) -> str : \" \"\" Return an object representation. Returns: str \"\" \" return f '<TypeMismatchError message={self.message!r}>'","title":"Module gophient.exc"},{"location":"reference/gophient/exc/#classes","text":"","title":"Classes"},{"location":"reference/gophient/exc/#gophererror","text":"class GopherError ( / , * args , ** kwargs ) View Source class GopherError ( Exception ) : \" \"\" Main class for all `gophient` exceptions. \"\" \"","title":"GopherError"},{"location":"reference/gophient/exc/#ancestors-in-mro","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/gophient/exc/#descendants","text":"gophient.exc.TypeMismatchError","title":"Descendants"},{"location":"reference/gophient/exc/#class-variables","text":"args","title":"Class variables"},{"location":"reference/gophient/exc/#methods","text":"","title":"Methods"},{"location":"reference/gophient/exc/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/gophient/exc/#typemismatcherror","text":"class TypeMismatchError ( got : str , expected : str ) View Source class TypeMismatchError ( GopherError ): \"\"\"Items' types mismatch.\"\"\" def __init__ ( self , got: str , expected: str ): \"\"\"Initialize an exception. Args: got (str): Item type expected (str): Expected type \"\"\" super (). __init__ () self . got = got self . expected = expected self . message = f'Expected { self . expected ! r } ( got { self . got ! r }). ' def __str__(self) -> str: \"\"\"Return a string representation of an exception. Returns: str \"\"\" return self.message def __repr__(self) -> str: \"\"\"Return an object representation. Returns: str \"\"\" return f'<TypeMismatchError message={self.message!r}> '","title":"TypeMismatchError"},{"location":"reference/gophient/exc/#ancestors-in-mro_1","text":"gophient.exc.GopherError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/gophient/exc/#class-variables_1","text":"args","title":"Class variables"},{"location":"reference/gophient/exc/#methods_1","text":"","title":"Methods"},{"location":"reference/gophient/exc/#with_traceback_1","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/gophient/types/","text":"Module gophient.types gophient.types - Types for gophient. None View Source \"\"\"gophient.types - Types for gophient.\"\"\" import socket import urllib.parse from dataclasses import dataclass , field from typing import ByteString , List , Union from gophient import const , exc @dataclass class Item : \"\"\"Line of a server response.\"\"\" raw_type : str = field ( compare = False , repr = False ) pretty_type : str = field ( compare = False ) port : int = 70 host : str = '' path : str = '' desc : str = '' _client : 'Gopher' = None @classmethod def parse ( cls , client : 'Gopher' , raw : ByteString ) -> Union [ 'Item' , None ]: \"\"\"Parse a raw `ByteString`. Args: client (Gopher): Related client raw (ByteString): Data to parse Returns: Union[Item, None] \"\"\" if raw in ( b '.' , b '' ): return None # Optional part of the specification try : raw = raw . decode ( client . encoding ) parts = raw [ 1 :] . split ( const . SEPARATOR ) if len ( parts ) < 4 : raise ValueError ( 'The server returned a file or a broken response.' ) except ValueError : return cls ( raw_type = '\uab30' , # Broken type to distinguish \"unparsable\" items pretty_type = const . TYPES . get ( '\uab30' , 'Unknown' ), ) return cls ( _client = client , raw_type = raw [ 0 ], pretty_type = const . TYPES . get ( raw [ 0 ], 'Unknown' ), desc = parts [ 0 ], path = parts [ 1 ], host = parts [ 2 ], port = int ( parts [ 3 ]), ) def merge_messages ( self , item : 'Item' ) -> None : \"\"\"Merge two informational messages. Args: item (Item): Item Raises: TypeMismatchError: Can't merge items with wrong types \"\"\" if self . raw_type == 'i' and item . raw_type == 'i' : self . desc += const . EOL . decode ( self . _client . encoding ) + item . desc else : raise exc . TypeMismatchError ( item . pretty_type , self . pretty_type ) def follow ( self ) -> Union [ List [ 'Item' ], list , ByteString ]: \"\"\"Follow the link. Returns: Union[List[Item], list, ByteString] \"\"\" return self . _client . request ( self . host , self . path , self . port , self . _client . encoding ) def __str__ ( self ) -> str : \"\"\"Return a string representation of the Item. Returns: str \"\"\" if self . raw_type == 'i' : return self . desc if self . raw_type == '\uab30' : return f 'File ( { self . path } on { self . host } : { self . port } )' return f ' { self . desc } ( { self . pretty_type } ) - { self . path } on { self . host } : { self . port } ' class Gopher : \"\"\"Class for Gopher client.\"\"\" def __init__ ( self , timeout : int = 10 , encoding : str = 'utf-8' ): \"\"\"Initialize a client. Args: timeout (int): Socket timeout encoding (str): Encoding for packets. Defaults to `'utf-8'` \"\"\" self . timeout = timeout self . encoding = encoding def _open_socket ( self ) -> socket . socket : \"\"\"Open a `socket.socket`. Returns: socket.socket \"\"\" return socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) def _prepare_payload ( self , path : str , query : Union [ str , ByteString , None ] = None ) -> bytes : \"\"\"Prepare a payload. Args: path (str): Path query (Union[str, ByteString, None]): Query. Defaults to `None`. Returns: bytes \"\"\" if isinstance ( query , str ): query = bytes ( urllib . parse . quote ( query , safe = '' ), self . encoding ) elif query is None : query = b '' path = bytes ( path , self . encoding ) return b '' . join (( path , b '?' , query , const . EOL )) def parse_response ( self , resp : ByteString ) -> Union [ List [ Item ], list , ByteString ]: \"\"\"Parse the server response. Args: resp (ByteString): Response Returns: Union[List[Item], list, ByteString] \"\"\" pretty_resp = [] for item in resp . split ( const . EOL ): item = Item . parse ( self , item ) if not item : continue if item . raw_type == '\uab30' : return resp if item . raw_type == 'i' and pretty_resp : if pretty_resp [ - 1 ] . raw_type == 'i' : pretty_resp [ - 1 ] . merge_messages ( item ) continue pretty_resp . append ( item ) return pretty_resp def request ( self , host : str , path : str = '/' , port : int = 70 , query : Union [ str , ByteString , None ] = None , ) -> Union [ List [ Item ], list , ByteString ]: \"\"\"Request an address. Args: host (str): Host to connect to path (str): Path. Defaults to `'/'` port (int): Port query (Union[str, ByteString, None]): Query Returns: Union[List[Item], list, ByteString] \"\"\" sock = self . _open_socket () with sock : socket . timeout ( self . timeout ) sock . connect (( host , port )) payload = self . _prepare_payload ( path , query ) sock . sendall ( payload ) resp = bytearray () packet = b 'packet' while packet : packet = sock . recv ( 1024 ) resp . extend ( packet ) return self . parse_response ( resp ) Classes Gopher class Gopher ( timeout : int = 10 , encoding : str = 'utf-8' ) View Source class Gopher : \"\"\"Class for Gopher client.\"\"\" def __init__ ( self , timeout : int = 10 , encoding : str = 'utf-8' ): \"\"\"Initialize a client. Args: timeout (int): Socket timeout encoding (str): Encoding for packets. Defaults to `'utf-8'` \"\"\" self . timeout = timeout self . encoding = encoding def _open_socket ( self ) -> socket . socket : \"\"\"Open a `socket.socket`. Returns: socket.socket \"\"\" return socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) def _prepare_payload ( self , path : str , query : Union [ str , ByteString , None ] = None ) -> bytes : \"\"\"Prepare a payload. Args: path (str): Path query (Union[str, ByteString, None]): Query. Defaults to `None`. Returns: bytes \"\"\" if isinstance ( query , str ): query = bytes ( urllib . parse . quote ( query , safe = '' ), self . encoding ) elif query is None : query = b '' path = bytes ( path , self . encoding ) return b '' . join (( path , b '?' , query , const . EOL )) def parse_response ( self , resp : ByteString ) -> Union [ List [ Item ], list , ByteString ]: \"\"\"Parse the server response. Args: resp (ByteString): Response Returns: Union[List[Item], list, ByteString] \"\"\" pretty_resp = [] for item in resp . split ( const . EOL ): item = Item . parse ( self , item ) if not item : continue if item . raw_type == '\uab30' : return resp if item . raw_type == 'i' and pretty_resp : if pretty_resp [ - 1 ] . raw_type == 'i' : pretty_resp [ - 1 ] . merge_messages ( item ) continue pretty_resp . append ( item ) return pretty_resp def request ( self , host : str , path : str = '/' , port : int = 70 , query : Union [ str , ByteString , None ] = None , ) -> Union [ List [ Item ], list , ByteString ]: \"\"\"Request an address. Args: host (str): Host to connect to path (str): Path. Defaults to `'/'` port (int): Port query (Union[str, ByteString, None]): Query Returns: Union[List[Item], list, ByteString] \"\"\" sock = self . _open_socket () with sock : socket . timeout ( self . timeout ) sock . connect (( host , port )) payload = self . _prepare_payload ( path , query ) sock . sendall ( payload ) resp = bytearray () packet = b 'packet' while packet : packet = sock . recv ( 1024 ) resp . extend ( packet ) return self . parse_response ( resp ) Methods parse_response def parse_response ( self , resp : ByteString ) -> Union [ List [ gophient . types . Item ], list , ByteString ] Parse the server response. Parameters: Name Type Description Default resp ByteString Response None Returns: Type Description None Union[List[Item], list, ByteString] View Source def parse_response ( self , resp : ByteString ) -> Union [ List[Item ] , list , ByteString ]: \"\"\"Parse the server response. Args: resp (ByteString): Response Returns: Union[List[Item], list, ByteString] \"\"\" pretty_resp = [] for item in resp . split ( const . EOL ) : item = Item . parse ( self , item ) if not item : continue if item . raw_type == '\uab30' : return resp if item . raw_type == 'i' and pretty_resp : if pretty_resp [ -1 ] . raw_type == 'i' : pretty_resp [ -1 ] . merge_messages ( item ) continue pretty_resp . append ( item ) return pretty_resp request def request ( self , host : str , path : str = '/' , port : int = 70 , query : Union [ str , ByteString , NoneType ] = None ) -> Union [ List [ gophient . types . Item ], list , ByteString ] Request an address. Parameters: Name Type Description Default host str Host to connect to None path str Path. Defaults to '/' None port int Port None query Union[str, ByteString, None] Query None Returns: Type Description None Union[List[Item], list, ByteString] View Source def request ( self , host : str , path : str = '/' , port : int = 70 , query : Union [ str, ByteString, None ] = None , ) -> Union [ List[Item ] , list , ByteString ]: \"\"\"Request an address. Args: host (str): Host to connect to path (str): Path. Defaults to `'/'` port (int): Port query (Union[str, ByteString, None]): Query Returns: Union[List[Item], list, ByteString] \"\"\" sock = self . _open_socket () with sock : socket . timeout ( self . timeout ) sock . connect (( host , port )) payload = self . _prepare_payload ( path , query ) sock . sendall ( payload ) resp = bytearray () packet = b 'packet' while packet : packet = sock . recv ( 1024 ) resp . extend ( packet ) return self . parse_response ( resp ) Item class Item ( raw_type : str , pretty_type : str , port : int = 70 , host : str = '' , path : str = '' , desc : str = '' , _client : 'Gopher' = None ) View Source @ dataclass class Item : \"\"\"Line of a server response.\"\"\" raw_type : str = field ( compare = False , repr = False ) pretty_type : str = field ( compare = False ) port : int = 70 host : str = '' path : str = '' desc : str = '' _client : 'Gopher' = None @ classmethod def parse ( cls , client : 'Gopher' , raw : ByteString ) -> Union [ 'Item' , None ]: \"\"\"Parse a raw `ByteString`. Args: client (Gopher): Related client raw (ByteString): Data to parse Returns: Union[Item, None] \"\"\" if raw in ( b '.' , b '' ): return None # Optional part of the specification try : raw = raw . decode ( client . encoding ) parts = raw [ 1 :] . split ( const . SEPARATOR ) if len ( parts ) < 4 : raise ValueError ( 'The server returned a file or a broken response.' ) except ValueError : return cls ( raw_type = '\uab30' , # Broken type to distinguish \"unparsable\" items pretty_type = const . TYPES . get ( '\uab30' , 'Unknown' ), ) return cls ( _client = client , raw_type = raw [ 0 ], pretty_type = const . TYPES . get ( raw [ 0 ], 'Unknown' ), desc = parts [ 0 ], path = parts [ 1 ], host = parts [ 2 ], port = int ( parts [ 3 ]), ) def merge_messages ( self , item : 'Item' ) -> None : \"\"\"Merge two informational messages. Args: item (Item): Item Raises: TypeMismatchError: Can't merge items with wrong types \"\"\" if self . raw_type == 'i' and item . raw_type == 'i' : self . desc += const . EOL . decode ( self . _client . encoding ) + item . desc else : raise exc . TypeMismatchError ( item . pretty_type , self . pretty_type ) def follow ( self ) -> Union [ List [ 'Item' ], list , ByteString ]: \"\"\"Follow the link. Returns: Union[List[Item], list, ByteString] \"\"\" return self . _client . request ( self . host , self . path , self . port , self . _client . encoding ) def __str__ ( self ) -> str : \"\"\"Return a string representation of the Item. Returns: str \"\"\" if self . raw_type == 'i' : return self . desc if self . raw_type == '\uab30' : return f 'File ({self.path} on {self.host}:{self.port})' return f '{self.desc} ({self.pretty_type}) - {self.path} on {self.host}:{self.port}' Class variables desc host path port Static methods parse def parse ( client : 'Gopher' , raw : ByteString ) -> Optional [ ForwardRef ( 'Item' )] Parse a raw ByteString . Parameters: Name Type Description Default client Gopher Related client None raw ByteString Data to parse None Returns: Type Description None Union[Item, None] View Source @classmethod def parse ( cls , client : 'Gopher' , raw : ByteString ) -> Union [ 'Item' , None ] : \" \"\" Parse a raw `ByteString`. Args: client (Gopher): Related client raw (ByteString): Data to parse Returns: Union[Item, None] \"\" \" if raw in ( b '.' , b '' ) : return None # Optional part of the specification try : raw = raw . decode ( client . encoding ) parts = raw [ 1 : ] . split ( const . SEPARATOR ) if len ( parts ) < 4 : raise ValueError ( 'The server returned a file or a broken response.' ) except ValueError : return cls ( raw_type = '\uab30' , # Broken type to distinguish \"unparsable\" items pretty_type = const . TYPES . get ( '\uab30' , 'Unknown' ), ) return cls ( _client = client , raw_type = raw [ 0 ] , pretty_type = const . TYPES . get ( raw [ 0 ] , 'Unknown' ), desc = parts [ 0 ] , path = parts [ 1 ] , host = parts [ 2 ] , port = int ( parts [ 3 ] ), ) Methods follow def follow ( self ) -> Union [ List [ ForwardRef ( 'Item' )], list , ByteString ] Follow the link. Returns: Type Description None Union[List[Item], list, ByteString] View Source def follow ( self ) -> Union [ List['Item' ] , list , ByteString ]: \"\"\"Follow the link. Returns: Union[List[Item], list, ByteString] \"\"\" return self . _client . request ( self . host , self . path , self . port , self . _client . encoding ) merge_messages def merge_messages ( self , item : 'Item' ) -> None Merge two informational messages. Parameters: Name Type Description Default item Item Item None Raises: Type Description TypeMismatchError Can't merge items with wrong types View Source def merge_messages ( self , item : 'Item' ) -> None : \"\"\"Merge two informational messages. Args: item (Item): Item Raises: TypeMismatchError: Can't merge items with wrong types \"\"\" if self . raw_type == 'i' and item . raw_type == 'i' : self . desc += const . EOL . decode ( self . _client . encoding ) + item . desc else : raise exc . TypeMismatchError ( item . pretty_type , self . pretty_type )","title":"Types"},{"location":"reference/gophient/types/#module-gophienttypes","text":"gophient.types - Types for gophient. None View Source \"\"\"gophient.types - Types for gophient.\"\"\" import socket import urllib.parse from dataclasses import dataclass , field from typing import ByteString , List , Union from gophient import const , exc @dataclass class Item : \"\"\"Line of a server response.\"\"\" raw_type : str = field ( compare = False , repr = False ) pretty_type : str = field ( compare = False ) port : int = 70 host : str = '' path : str = '' desc : str = '' _client : 'Gopher' = None @classmethod def parse ( cls , client : 'Gopher' , raw : ByteString ) -> Union [ 'Item' , None ]: \"\"\"Parse a raw `ByteString`. Args: client (Gopher): Related client raw (ByteString): Data to parse Returns: Union[Item, None] \"\"\" if raw in ( b '.' , b '' ): return None # Optional part of the specification try : raw = raw . decode ( client . encoding ) parts = raw [ 1 :] . split ( const . SEPARATOR ) if len ( parts ) < 4 : raise ValueError ( 'The server returned a file or a broken response.' ) except ValueError : return cls ( raw_type = '\uab30' , # Broken type to distinguish \"unparsable\" items pretty_type = const . TYPES . get ( '\uab30' , 'Unknown' ), ) return cls ( _client = client , raw_type = raw [ 0 ], pretty_type = const . TYPES . get ( raw [ 0 ], 'Unknown' ), desc = parts [ 0 ], path = parts [ 1 ], host = parts [ 2 ], port = int ( parts [ 3 ]), ) def merge_messages ( self , item : 'Item' ) -> None : \"\"\"Merge two informational messages. Args: item (Item): Item Raises: TypeMismatchError: Can't merge items with wrong types \"\"\" if self . raw_type == 'i' and item . raw_type == 'i' : self . desc += const . EOL . decode ( self . _client . encoding ) + item . desc else : raise exc . TypeMismatchError ( item . pretty_type , self . pretty_type ) def follow ( self ) -> Union [ List [ 'Item' ], list , ByteString ]: \"\"\"Follow the link. Returns: Union[List[Item], list, ByteString] \"\"\" return self . _client . request ( self . host , self . path , self . port , self . _client . encoding ) def __str__ ( self ) -> str : \"\"\"Return a string representation of the Item. Returns: str \"\"\" if self . raw_type == 'i' : return self . desc if self . raw_type == '\uab30' : return f 'File ( { self . path } on { self . host } : { self . port } )' return f ' { self . desc } ( { self . pretty_type } ) - { self . path } on { self . host } : { self . port } ' class Gopher : \"\"\"Class for Gopher client.\"\"\" def __init__ ( self , timeout : int = 10 , encoding : str = 'utf-8' ): \"\"\"Initialize a client. Args: timeout (int): Socket timeout encoding (str): Encoding for packets. Defaults to `'utf-8'` \"\"\" self . timeout = timeout self . encoding = encoding def _open_socket ( self ) -> socket . socket : \"\"\"Open a `socket.socket`. Returns: socket.socket \"\"\" return socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) def _prepare_payload ( self , path : str , query : Union [ str , ByteString , None ] = None ) -> bytes : \"\"\"Prepare a payload. Args: path (str): Path query (Union[str, ByteString, None]): Query. Defaults to `None`. Returns: bytes \"\"\" if isinstance ( query , str ): query = bytes ( urllib . parse . quote ( query , safe = '' ), self . encoding ) elif query is None : query = b '' path = bytes ( path , self . encoding ) return b '' . join (( path , b '?' , query , const . EOL )) def parse_response ( self , resp : ByteString ) -> Union [ List [ Item ], list , ByteString ]: \"\"\"Parse the server response. Args: resp (ByteString): Response Returns: Union[List[Item], list, ByteString] \"\"\" pretty_resp = [] for item in resp . split ( const . EOL ): item = Item . parse ( self , item ) if not item : continue if item . raw_type == '\uab30' : return resp if item . raw_type == 'i' and pretty_resp : if pretty_resp [ - 1 ] . raw_type == 'i' : pretty_resp [ - 1 ] . merge_messages ( item ) continue pretty_resp . append ( item ) return pretty_resp def request ( self , host : str , path : str = '/' , port : int = 70 , query : Union [ str , ByteString , None ] = None , ) -> Union [ List [ Item ], list , ByteString ]: \"\"\"Request an address. Args: host (str): Host to connect to path (str): Path. Defaults to `'/'` port (int): Port query (Union[str, ByteString, None]): Query Returns: Union[List[Item], list, ByteString] \"\"\" sock = self . _open_socket () with sock : socket . timeout ( self . timeout ) sock . connect (( host , port )) payload = self . _prepare_payload ( path , query ) sock . sendall ( payload ) resp = bytearray () packet = b 'packet' while packet : packet = sock . recv ( 1024 ) resp . extend ( packet ) return self . parse_response ( resp )","title":"Module gophient.types"},{"location":"reference/gophient/types/#classes","text":"","title":"Classes"},{"location":"reference/gophient/types/#gopher","text":"class Gopher ( timeout : int = 10 , encoding : str = 'utf-8' ) View Source class Gopher : \"\"\"Class for Gopher client.\"\"\" def __init__ ( self , timeout : int = 10 , encoding : str = 'utf-8' ): \"\"\"Initialize a client. Args: timeout (int): Socket timeout encoding (str): Encoding for packets. Defaults to `'utf-8'` \"\"\" self . timeout = timeout self . encoding = encoding def _open_socket ( self ) -> socket . socket : \"\"\"Open a `socket.socket`. Returns: socket.socket \"\"\" return socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) def _prepare_payload ( self , path : str , query : Union [ str , ByteString , None ] = None ) -> bytes : \"\"\"Prepare a payload. Args: path (str): Path query (Union[str, ByteString, None]): Query. Defaults to `None`. Returns: bytes \"\"\" if isinstance ( query , str ): query = bytes ( urllib . parse . quote ( query , safe = '' ), self . encoding ) elif query is None : query = b '' path = bytes ( path , self . encoding ) return b '' . join (( path , b '?' , query , const . EOL )) def parse_response ( self , resp : ByteString ) -> Union [ List [ Item ], list , ByteString ]: \"\"\"Parse the server response. Args: resp (ByteString): Response Returns: Union[List[Item], list, ByteString] \"\"\" pretty_resp = [] for item in resp . split ( const . EOL ): item = Item . parse ( self , item ) if not item : continue if item . raw_type == '\uab30' : return resp if item . raw_type == 'i' and pretty_resp : if pretty_resp [ - 1 ] . raw_type == 'i' : pretty_resp [ - 1 ] . merge_messages ( item ) continue pretty_resp . append ( item ) return pretty_resp def request ( self , host : str , path : str = '/' , port : int = 70 , query : Union [ str , ByteString , None ] = None , ) -> Union [ List [ Item ], list , ByteString ]: \"\"\"Request an address. Args: host (str): Host to connect to path (str): Path. Defaults to `'/'` port (int): Port query (Union[str, ByteString, None]): Query Returns: Union[List[Item], list, ByteString] \"\"\" sock = self . _open_socket () with sock : socket . timeout ( self . timeout ) sock . connect (( host , port )) payload = self . _prepare_payload ( path , query ) sock . sendall ( payload ) resp = bytearray () packet = b 'packet' while packet : packet = sock . recv ( 1024 ) resp . extend ( packet ) return self . parse_response ( resp )","title":"Gopher"},{"location":"reference/gophient/types/#methods","text":"","title":"Methods"},{"location":"reference/gophient/types/#parse_response","text":"def parse_response ( self , resp : ByteString ) -> Union [ List [ gophient . types . Item ], list , ByteString ] Parse the server response. Parameters: Name Type Description Default resp ByteString Response None Returns: Type Description None Union[List[Item], list, ByteString] View Source def parse_response ( self , resp : ByteString ) -> Union [ List[Item ] , list , ByteString ]: \"\"\"Parse the server response. Args: resp (ByteString): Response Returns: Union[List[Item], list, ByteString] \"\"\" pretty_resp = [] for item in resp . split ( const . EOL ) : item = Item . parse ( self , item ) if not item : continue if item . raw_type == '\uab30' : return resp if item . raw_type == 'i' and pretty_resp : if pretty_resp [ -1 ] . raw_type == 'i' : pretty_resp [ -1 ] . merge_messages ( item ) continue pretty_resp . append ( item ) return pretty_resp","title":"parse_response"},{"location":"reference/gophient/types/#request","text":"def request ( self , host : str , path : str = '/' , port : int = 70 , query : Union [ str , ByteString , NoneType ] = None ) -> Union [ List [ gophient . types . Item ], list , ByteString ] Request an address. Parameters: Name Type Description Default host str Host to connect to None path str Path. Defaults to '/' None port int Port None query Union[str, ByteString, None] Query None Returns: Type Description None Union[List[Item], list, ByteString] View Source def request ( self , host : str , path : str = '/' , port : int = 70 , query : Union [ str, ByteString, None ] = None , ) -> Union [ List[Item ] , list , ByteString ]: \"\"\"Request an address. Args: host (str): Host to connect to path (str): Path. Defaults to `'/'` port (int): Port query (Union[str, ByteString, None]): Query Returns: Union[List[Item], list, ByteString] \"\"\" sock = self . _open_socket () with sock : socket . timeout ( self . timeout ) sock . connect (( host , port )) payload = self . _prepare_payload ( path , query ) sock . sendall ( payload ) resp = bytearray () packet = b 'packet' while packet : packet = sock . recv ( 1024 ) resp . extend ( packet ) return self . parse_response ( resp )","title":"request"},{"location":"reference/gophient/types/#item","text":"class Item ( raw_type : str , pretty_type : str , port : int = 70 , host : str = '' , path : str = '' , desc : str = '' , _client : 'Gopher' = None ) View Source @ dataclass class Item : \"\"\"Line of a server response.\"\"\" raw_type : str = field ( compare = False , repr = False ) pretty_type : str = field ( compare = False ) port : int = 70 host : str = '' path : str = '' desc : str = '' _client : 'Gopher' = None @ classmethod def parse ( cls , client : 'Gopher' , raw : ByteString ) -> Union [ 'Item' , None ]: \"\"\"Parse a raw `ByteString`. Args: client (Gopher): Related client raw (ByteString): Data to parse Returns: Union[Item, None] \"\"\" if raw in ( b '.' , b '' ): return None # Optional part of the specification try : raw = raw . decode ( client . encoding ) parts = raw [ 1 :] . split ( const . SEPARATOR ) if len ( parts ) < 4 : raise ValueError ( 'The server returned a file or a broken response.' ) except ValueError : return cls ( raw_type = '\uab30' , # Broken type to distinguish \"unparsable\" items pretty_type = const . TYPES . get ( '\uab30' , 'Unknown' ), ) return cls ( _client = client , raw_type = raw [ 0 ], pretty_type = const . TYPES . get ( raw [ 0 ], 'Unknown' ), desc = parts [ 0 ], path = parts [ 1 ], host = parts [ 2 ], port = int ( parts [ 3 ]), ) def merge_messages ( self , item : 'Item' ) -> None : \"\"\"Merge two informational messages. Args: item (Item): Item Raises: TypeMismatchError: Can't merge items with wrong types \"\"\" if self . raw_type == 'i' and item . raw_type == 'i' : self . desc += const . EOL . decode ( self . _client . encoding ) + item . desc else : raise exc . TypeMismatchError ( item . pretty_type , self . pretty_type ) def follow ( self ) -> Union [ List [ 'Item' ], list , ByteString ]: \"\"\"Follow the link. Returns: Union[List[Item], list, ByteString] \"\"\" return self . _client . request ( self . host , self . path , self . port , self . _client . encoding ) def __str__ ( self ) -> str : \"\"\"Return a string representation of the Item. Returns: str \"\"\" if self . raw_type == 'i' : return self . desc if self . raw_type == '\uab30' : return f 'File ({self.path} on {self.host}:{self.port})' return f '{self.desc} ({self.pretty_type}) - {self.path} on {self.host}:{self.port}'","title":"Item"},{"location":"reference/gophient/types/#class-variables","text":"desc host path port","title":"Class variables"},{"location":"reference/gophient/types/#static-methods","text":"","title":"Static methods"},{"location":"reference/gophient/types/#parse","text":"def parse ( client : 'Gopher' , raw : ByteString ) -> Optional [ ForwardRef ( 'Item' )] Parse a raw ByteString . Parameters: Name Type Description Default client Gopher Related client None raw ByteString Data to parse None Returns: Type Description None Union[Item, None] View Source @classmethod def parse ( cls , client : 'Gopher' , raw : ByteString ) -> Union [ 'Item' , None ] : \" \"\" Parse a raw `ByteString`. Args: client (Gopher): Related client raw (ByteString): Data to parse Returns: Union[Item, None] \"\" \" if raw in ( b '.' , b '' ) : return None # Optional part of the specification try : raw = raw . decode ( client . encoding ) parts = raw [ 1 : ] . split ( const . SEPARATOR ) if len ( parts ) < 4 : raise ValueError ( 'The server returned a file or a broken response.' ) except ValueError : return cls ( raw_type = '\uab30' , # Broken type to distinguish \"unparsable\" items pretty_type = const . TYPES . get ( '\uab30' , 'Unknown' ), ) return cls ( _client = client , raw_type = raw [ 0 ] , pretty_type = const . TYPES . get ( raw [ 0 ] , 'Unknown' ), desc = parts [ 0 ] , path = parts [ 1 ] , host = parts [ 2 ] , port = int ( parts [ 3 ] ), )","title":"parse"},{"location":"reference/gophient/types/#methods_1","text":"","title":"Methods"},{"location":"reference/gophient/types/#follow","text":"def follow ( self ) -> Union [ List [ ForwardRef ( 'Item' )], list , ByteString ] Follow the link. Returns: Type Description None Union[List[Item], list, ByteString] View Source def follow ( self ) -> Union [ List['Item' ] , list , ByteString ]: \"\"\"Follow the link. Returns: Union[List[Item], list, ByteString] \"\"\" return self . _client . request ( self . host , self . path , self . port , self . _client . encoding )","title":"follow"},{"location":"reference/gophient/types/#merge_messages","text":"def merge_messages ( self , item : 'Item' ) -> None Merge two informational messages. Parameters: Name Type Description Default item Item Item None Raises: Type Description TypeMismatchError Can't merge items with wrong types View Source def merge_messages ( self , item : 'Item' ) -> None : \"\"\"Merge two informational messages. Args: item (Item): Item Raises: TypeMismatchError: Can't merge items with wrong types \"\"\" if self . raw_type == 'i' and item . raw_type == 'i' : self . desc += const . EOL . decode ( self . _client . encoding ) + item . desc else : raise exc . TypeMismatchError ( item . pretty_type , self . pretty_type )","title":"merge_messages"}]}